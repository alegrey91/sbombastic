|              |                                                                |
| :----------- | :------------------------------------------------------------- |
| Feature Name | Vulnerability Report                                           |
| Start Date   | 31/07/2025                                                     |
| Category     | Architecture                                                   |
| RFC PR       | [#356](https://github.com/kubewarden/sbomscanner/pull/356) |
| State        | **ACCEPTED**                                                   |

# Summary

[summary]: #summary

<!---
Brief (one-paragraph) explanation of the feature.
--->

Vulnerability Report is a fundamental part of SBOMscanner, designed to define
and organize scan results into a format that is readable, easily parsable,
and suitable for persistent storage.

# Motivation

[motivation]: #motivation

<!---
- Why are we doing this?
- What use cases does it support?
- What is the expected outcome?

Describe the problem you are trying to solve, and its constraints, without
coupling them too closely to the solution you have in mind. If this RFC is not
accepted, the motivation can be used to develop alternative solutions.
--->

We aim to define our own `VulnerabilityReport` format to effectively store
scanning results in the storage component (e.g., PostgreSQL).
This will enable the UI to present the security posture of the cluster,
providing users with actionable insights and historical visibility.

## Examples / User Stories

[examples]: #examples

<!---
Examples of how the feature will be used. Interactions should show the action
and the response. When appropriate, provide user stories in the form of "As a
[role], I want [feature], so [that]."
--->

The Vulnerability Report will be used to store scanning results into the
storage component.
The user will have it available to see the status of the cluster,
aggregating information from multiple reports over the time.

### User story #1

As a user, I want to consult the `VulnerabilityReport` after a scan has
completed, so that I can apply remediations to affected images.

### User story #2

As a user, I want to access stored `VulnerabilityReport`s, so that I can use
the data in a third-party UI dashboard.

# Detailed design

[design]: #detailed-design

<!---
This is the bulk of the RFC. Explain the design in enough detail for somebody
familiar with the product to understand, and for somebody familiar with the
internals to implement.

This section should cover architecture aspects and the rationale behind
disruptive technical decisions (when applicable), as well as corner-cases and
warnings.
--->

Currently, we store scan results in the `VulnerabilityReport` CRD using a
single field named `sarif`, stored as a `runtime.RawExtension`.
This results in unstructured binary data that limits our ability to query
or process it effectively.

To support data analysis and structured querying, we propose replace the
`sarif` field with the following structure:

```yaml
apiVersion: storage.sbomscanner.kubewarden.io/v1alpha1
kind: VulnerabilityReport
metadata:
  name: vulnreport-xxxx
  namespace: default
report:
  summary:
    critical: 0
    high: 5
    medium: 10
    low: 2
    unknown: 1
    suppressed: 3
  results: [...]
```

Each `result` represents scan data for a specific `target`, the component
where vulnerabilities were found.

- `class` identifies the way the `target` was installed on the system.
  As you might notice, `Class` has its own data type which limits the value to
  3 possible options:

      * operating system package manager `os-pkgs`
      * language package manager `lang-pkgs`
      * compiled binary file `binary`

- `type` identify the language of the `target` (eg. `go`, `rust`, `c`, etc).
- `vulnerabilities` is a list of type `vulnerability`, that we will see later.

```yaml
report:
  results:
    - target: "/opt/vulnerable-bin"
      class: "binary"
      type: "go"
      vulnerabilities: []
    - target: "/opt/vulnerable-bin-2"
      class: "lang-pkgs"
      type: "rust"
      vulnerabilities: []
```

`vulnerability` holds information about the target exposure.

- `cve` is the Common Vulnerabilities and Exposures identifier
  (e.g., CVE-2024-1234). It uniquely identifies the vulnerability in public
  databases.
- `title` is the title of the vulnerability.
- `packageName` is the name of the affected software package where the
  vulnerability was found.
- `packagePath` is the path to the package in the file system or within a
  container layer. Useful for locating the affected component in complex projects.
- `purl` ([Package URL](https://github.com/package-url/purl-spec/blob/main/PURL-SPECIFICATION.rst))
  is a standardized way to describe and identify the software package, useful
  for correlation across tools and ecosystems.
- `installedVersion` is the version of the package that is currently installed
  and affected by the vulnerability.
- `fixedVersions` is a list of versions where the vulnerability has been
  addressed. Helps determine what upgrade paths are available.
- `layerDiffID` is the unique identifier of the container image layer that
  introduced the package. Useful for tracing the origin of the vulnerability
  in layered images.
- `description` provides a human-readable explanation of the vulnerability.
- `severity` indicates the criticality level of the vulnerability
  (e.g., LOW, MEDIUM, HIGH, CRITICAL).
- `cvss` contains the CVSS (Common Vulnerability Scoring System) score and
  vector, used to quantify the severity of the vulnerability.
- `references` is a list of URLs or documentation links for further reading
  or remediation steps.
- `suppressed` indicates whether the vulnerability has been suppressed
  (by a VEX document).
- `vexStatus` provides the VEX (Vulnerability Exploitability eXchange) status.

```yaml
report:
  results:
    - target: "/opt/vulnerable-bin"
      class: "binary"
      type: "go"
      vulnerabilities:
        - cve: "CVE-2024-12345"
          title: "libcurl: Double Close of Eventfd"
          packageName: "curl"
          packagePath: "/usr/bin/curl"
          purl: "pkg:apk/alpine/curl@8.11.1-r0"
          installedVersion: "8.11.1-r0"
          fixedVersions:
            - "8.12.0-r0"
          layerDiffID: "sha256:96b9ae457f59557b"
          description: "libcurl would wrongly close the same eventfd"
          severity: "3"
          references:
            - "http://www.openwall.com/lists/oss-security/2025/02/05/2"
            - "https://hackerone.com/reports/2954286"
```

`cvss` holds information about the scoring system and has a dedicated
structure.

- `v3vector` encodes the individual metrics used to calculate the
  vulnerability's severity score.
- `v3score` is the numerical severity score (typically from 0.0 to 10.0) based
  on the CVSS v3 specification.

```yaml
report:
  results:
    - target: "/opt/vulnerable-bin"
      class: "binary"
      type: "go"
      vulnerabilities:
        - cve: "CVE-2024-12345"
          ...
          cvss:
            v3vector: "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H"
            v3score: 7
```

`vexStatus` reports information about VEX only when the
`vulnerability.suppressed` is `true`, otherwise this is empty.

- `repository` is the VEX repo used to suppress it.
- `status` is the status of the vulnerability such as `not_affected`,
  `affected`, `fixed`, or `under_investigation`.
- `statement` explains more about the status
  (eg. `vulnerable_code_not_present`).

```yaml
report:
  results:
    - target: "/opt/vulnerable-bin"
      class: "binary"
      type: "go"
      vulnerabilities:
        - cve: "CVE-2024-12345"
          ...
          vexStatus:
            repository: "https://github.com/kubewarden/vexhub"
            status: "not_affected"
            statement: "vulnerable_code_not_present"
```

The `VulnerabilityReport` will include a `summary` section showing vulnerability counts by severity (critical, high, medium, low, unknown) and a `suppressed` count.
If some vulnerabilities are suppressed by a VEX match, they are subtracted from the severity counts and shown under `suppressed`.

In this case, the scanned image originally had 10 critical vulnerabilities. VEX suppressed 2 of them, so the report shows 8 remaining critical issues and a suppressed count of 2:

```yaml
report:
  summary:
    critical: 8 # 10 total - 2 suppressed
    high: 2
    medium: 0
    low: 40
    unknown: 0
    suppressed: 2
```

# Drawbacks

[drawbacks]: #drawbacks

<!---
Why should we **not** do this?

  * obscure corner cases
  * will it impact performance?
  * what other parts of the product will be affected?
  * will the solution be hard to maintain in the future?
--->

# Alternatives

[alternatives]: #alternatives

<!---
- What other designs/options have been considered?
- What is the impact of not doing this?
--->

# Unresolved questions

[unresolved]: #unresolved-questions

<!---
- What are the unknowns?
- What can happen if Murphy's law holds true?
--->

We are currently using Trivy as scanning tool for our scans. In the future we
plan to add support for more scanners to improve the quality of the scans.

The proposed structure is inspired to the Trivy report format, which can add
complexity when adding support for other tool formats.
For now the `grype` format looks applicable, but we have to carefully add new
fields in the future to ensure that they will be supported by other tools
as well.
