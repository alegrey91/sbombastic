package storage

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/jmoiron/sqlx"
	"github.com/rancher/sbombastic/api/storage/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/generic/registry"
)

const CreateVulnerabilityReportTableSQL = `
CREATE TABLE IF NOT EXISTS vulnerabilityreports (
    id INTEGER PRIMARY KEY,
    name VARCHAR(253) NOT NULL,
    namespace VARCHAR(253) NOT NULL,
    object TEXT NOT NULL,
    UNIQUE(name, namespace)
);
`

// NewVulnerabilityReport returns a store registry that will work against API services.
func NewVulnerabilityReport(
	scheme *runtime.Scheme,
	optsGetter generic.RESTOptionsGetter,
	db *sqlx.DB,
	logger *slog.Logger,
) (*registry.Store, error) {
	strategy := newVulnerabilityReportStrategy(scheme)

	newFunc := func() runtime.Object { return &v1alpha1.VulnerabilityReport{} }
	newListFunc := func() runtime.Object { return &v1alpha1.VulnerabilityReportList{} }

	store := &registry.Store{
		NewFunc:                   newFunc,
		NewListFunc:               newListFunc,
		PredicateFunc:             matcher,
		DefaultQualifiedResource:  v1alpha1.Resource("vulnerabilityreports"),
		SingularQualifiedResource: v1alpha1.Resource("vulnerabilityreport"),
		Storage: registry.DryRunnableStorage{
			Storage: &store{
				db:          db,
				broadcaster: watch.NewBroadcaster(1000, watch.WaitIfChannelFull),
				table:       "vulnerabilityreports",
				newFunc:     newFunc,
				newListFunc: newListFunc,
				logger:      logger.With("store", "vulnerabilityreport"),
			},
		},
		CreateStrategy: strategy,
		UpdateStrategy: strategy,
		DeleteStrategy: strategy,
		TableConvertor: &vulnerabilityReportTableConvertor{},
	}

	options := &generic.StoreOptions{RESTOptions: optsGetter, AttrFunc: getAttrs}
	if err := store.CompleteWithOptions(options); err != nil {
		return nil, fmt.Errorf("unable to complete store with options: %w", err)
	}

	return store, nil
}

type vulnerabilityReportTableConvertor struct{}

func (c *vulnerabilityReportTableConvertor) ConvertToTable(_ context.Context, obj runtime.Object, _ runtime.Object) (*metav1.Table, error) {
	columns := append(
		imageMetadataTableColumns(),
		metav1.TableColumnDefinition{Name: "Vulnerabilities", Type: "string", Description: "Vulnerabilities"},
	)

	table := &metav1.Table{
		ColumnDefinitions: columns,
		Rows:              []metav1.TableRow{},
	}

	// Handle both single object and list
	var reports []v1alpha1.VulnerabilityReport
	switch t := obj.(type) {
	case *v1alpha1.VulnerabilityReportList:
		reports = t.Items
	case *v1alpha1.VulnerabilityReport:
		reports = []v1alpha1.VulnerabilityReport{*t}
	default:
		return nil, fmt.Errorf("unexpected type %T", obj)
	}

	for _, report := range reports {
		cells := append(
			imageMetadataTableRowCells(report.Name, &report),
			computeVulnerabilities(&report),
		)
		row := metav1.TableRow{
			Object: runtime.RawExtension{Object: &report},
			Cells:  cells,
		}
		table.Rows = append(table.Rows, row)
	}

	return table, nil
}

func computeVulnerabilities(vulnerabilityreport *v1alpha1.VulnerabilityReport) string {
	var suppressed int
	for _, result := range vulnerabilityreport.Report.Results {
		for _, vuln := range result.Vulnerabilities {
			if vuln.Suppressed {
				suppressed++
				continue
			}
		}
	}
	vulnerabilities := len(vulnerabilityreport.Report.Results) - suppressed

	return fmt.Sprintf("%d (%d suppressed)", vulnerabilities, suppressed)
}
